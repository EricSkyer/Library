namespace Lib.Exercise
{
    //## Graphs

    //Graphs can be used to represent many problems in computer science, so this section is long, like trees and sorting were.

    //- Notes from Yegge:
    //    - There are three basic ways to represent a graph in memory:
    //        - objects and pointers
    //        - matrix
    //        - adjacency list
    //    - Familiarize yourself with each representation and its pros & cons
    //    - BFS and DFS - know their computational complexity, their tradeoffs, and how to implement them in real code
    //    - When asked a question, look for a graph-based solution first, then move on if none.

    //- I'll implement:
    //    - [ ] DFS with adjacency list (recursive)
    //    - [ ] DFS with adjacency list (iterative with stack)
    //    - [ ] DFS with adjacency matrix (recursive)
    //    - [ ] DFS with adjacency matrix (iterative with stack)
    //    - [ ] BFS with adjacency list
    //    - [ ] BFS with adjacency matrix
    //    - [ ] single-source shortest path (Dijkstra)
    //    - [ ] minimum spanning tree
    //    - DFS-based algorithms (see Aduni videos above):
    //        - [ ] check for cycle (needed for topological sort, since we'll check for cycle before starting)
    //        - [ ] topological sort
    //        - [ ] count connected components in a graph
    //        - [ ] list strongly connected components
    //        - [ ] check for bipartite graph

    public class Class5
    {

    }
}
